---
title: 'useExtracted: The Tailwind of i18n?'
---

import StayUpdated from '@/components/StayUpdated.mdx';

# useExtracted: The Tailwind of i18n?

<small>Nov 7, 2025 · by Jan Amann</small>

For quite some time, I used to be a Tailwind skeptic. But one day, I decided to _give it five minutes_ — and I never looked back. It's core idea is just so irresistibly pragmatic. Once you've tried it, you just can't go back.

It made me wonder: "What would the Tailwind for i18n look like?"

Now first of all, `next-intl` is doing very well and has recently crossed [1M weekly downloads](https://www.npmjs.com/package/next-intl). So it seems like there are plenty of people who are quite happy with it.

But will we continue to write code the same way tomorrow, as we do today?

It seems evident that we will not. AI agents are increasingly making their way into our workflows, and innovations like Cursor and Claude Code are becoming more powerful by the day.

So what makes a library suitable for AI-first development? Probably, that it was already a great option for humans in the first place. In the case of Tailwind: Why did it virtually become the standard for styling?

## Design principles

If we consider the design of Tailwind, we can see that an i18n solution that follows the same principles might look something like this:

1. **Colocation**: Similar to how Tailwind avoids the need to manage separate stylesheets, there should not be a need for manually managing JSON message catalogs when adding, updating or removing messages. Message catalogs can however act as a compile target.
2. **Local reasoning**: Generative AI is very good at Tailwind since it only requires very small context windows. Having to read entire message catalogs leads to context pollution and should therefore not be necessary (at least not without tool calls).
3. **No naming of things**: Not having to come up with names is a major productivity boost, therefore manual keys should be avoided as much as possible.
4. **Purging**: When code is quickly changed, there should not be any dead code left behind. Similar to how Tailwind can purge unused styles, we should purge unused messages automatically.
5. **Minification**: Tailwind class names have a tiny bundle footprint. In the same way, messages should also use minified keys that ensures bundles are as small as possible.
6. **Prototype-friendly, production-ready**: Tailwind looks exactly the same, regardless of whether it is used for a quick prototype or a production app. In the same way, there should be a single API that avoids upfront structural decisions related to the project's size and complexity.
7. **Refactoring-friendly**: Moving code across components is seamless with Tailwind, this should be the case for your messages as well.

While `next-intl` has answers to some of these questions, ultimately the truth is that there's currently potential left on the table. Therefore, after [publishing an RFC](https://github.com/amannn/next-intl/blob/main/rfcs/001-message-extraction.md) about two months ago — today, I'm incredibly excited to share what I believe can be the answer to the questions above:

```tsx
import {useExtracted} from 'next-intl';
```

## `useExtracted` in action

I already made you read far too much, so let's just dive right in.

Let's start with an app that has `next-intl` installed, and we'll make a previously static label eligible for translation:

video:

- start with hardcoded label
- start using useExtracted with "Hello Jane"
- show en.json

No naming of keys, no CLI to invoke, just `next dev` as you're used to.

And you get your JSON catalog for free.

## Everything you like about `useTranslations`, but without the keys

If you've internationalized an app before, of course you know that we need to translate more than just plain strings. So let's use some ICU features:

video

- use a variable like "Nice to meet you, `{name}`!"
- "import counter (static labels)"
- turn counter into translated (should heavily use cursor suggestions)

Yep, TypeScript will automatically validate that you're using the `number` formatter when you're passing a number to a message. By doing this, `Intl.NumberFormat` will be used behind the scenes, turning a raw number into a readable string that uses locale-sensitive formatting.

Ok. So this code appears to be easy to generate for AIs, all without having to load lengthy message catalogs into its precious context window.

But what about using AI to translate your messages?

## Context is key

While providing context was always important for translators, it seems like in the AI era, doing this in an easy-to-digest way that's based on text is even more important.

If you've previously used hand-crafted keys like `auth.login.title`, you already did your part to provide some context. But what if our translations look like this:

```json
{
  "0MXX5B": "Welcome back!"
}
```

Not so easy.

But again, making something easy for AIs was probably always about making it easy for humans in the first place. And we already found a solution for this — wait for it — 35 years ago!

[GNU gettext](https://en.wikipedia.org/wiki/Gettext) came up with `.po` files, which look like this:

```po
#: src/app/(auth)/login/page.tsx
#. Greeting shown to user when they are logged in
msgid "0MXX5B"
msgstr "Welcome back!"
```

Everything is there: A file name, an optional description, an ID and the label itself.

So this is what you'll now be able to use with `next-intl` as well:

video:

- delete messages
- open config, enable .po formatter
- start dev server
- show messages

Note how enabling the `.po` formatter also activates a Turbopack loader that will parse your locale catalogs as JSON for you.

## Now we're ready to translate

With this, we're in a much better position to get accurate and user-friendly translations.

So first of all, let's add a new locale:

video:

- add de.json (initialized)

Nope, this wasn't cut. When you add a new locale, `next-intl` will automatically populate it with empty entries for all messages that you support.

So from here, you can start translating your messages, in the easiest case by using an AI-based translation service like [Crowdin](/docs/workflows/localization-management):

video:

- upload
- download
- use locale switcher

## Wrapping up

Ok, I could probably go on, e.g. about how `useExtracted` also works out-of-the-box in test environments without having to configure anything, but I think I've already made my point.

If you're excited about this as well, I'd really love to hear your feedback.

Give the [demo app](https://github.com/amannn/next-intl-example-extracted) a try and [share your feedback](https://github.com/amannn/next-intl/discussions/2036) with me. If you're an early adopter, you can already try this feature in your app with `next-intl@4.5`, but please note that it's currently considered experimental.

I'm looking forward to hearing what you think!

— Jan

**Further reading:**

- [Message extraction docs](/docs/usage/extraction)
- [Next.js plugin docs](/docs/usage/plugin)
- [RFC: Message extraction](https://github.com/amannn/next-intl/blob/main/rfcs/001-message-extraction.md)

PS: A special thank you goes to projects & companies like [gettext](https://en.wikipedia.org/wiki/Gettext), [Lingui](https://lingui.dev/), [FormatJS](https://formatjs.github.io/), [Wordpress](https://www.npmjs.com/package/@wordpress/i18n), and [Zendesk](https://www.youtube.com/watch?v=fUQAXo2DayQ) for their pioneering work in this space.

<StayUpdated />
