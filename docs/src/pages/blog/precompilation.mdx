---
title: 'Ahead-of-time compilation for next-intl'
subtitle: Dropping the parser
---

import StayUpdated from '@/components/StayUpdated.mdx';

# Ahead-of-time compilation for next-intl

<small>Jan 16, 2025 · by Jan Amann</small>

When React Server Components were announced, I was pretty excited.

I immediately saw [potential for `next-intl`](https://www.smashingmagazine.com/2023/03/internationalization-nextjs-13-react-server-components/) to improve performance for its users by moving more work to the server—leaving the client with less JavaScript to parse and evaluate.

But I have to admit, I got a bit carried away. While for very interactive apps this was never really an option anyway, when working on apps with very sensitive performance requirements, I'd almost dogmatically avoid client-side translations entirely.

And while you can get [pretty far](https://next-intl.dev/docs/environments/server-client-components#using-internationalization-in-client-components) with this approach, it can require quite some tricks like leaning heavily into ["donut components"](https://nextjs.org/docs/app/getting-started/server-and-client-components#interleaving-server-and-client-components) and other fancy patterns.

It almost felt like a game of "the floor is lava", trying to find clever tricks that would help to ultimately avoid shipping an ICU parser to the client. I know some of you did the same thing.

## A different perspective

About three years ago, I started a conversation with [Jan Nicklas](https://x.com/jantimon), about how we could best leverage the new Server Components paradigm for internationalization.

At some point, he shared an idea with me that he'd implement in a prototype: [`icu-to-json`](https://github.com/jantimon/icu-to-json)—a fresh take on removing the ICU parser from the runtime.

I always wanted to integrate this into `next-intl`, but for the longest time, it seemed like a big ask architecturally for the library.

But then, about two months ago, I shared the first implementation of [`useExtracted`](/docs/usage/extraction) with you—which happened to provide the infrastructure that finally unlocked this feature.

The loader I've implemented for processing `.po` files, and later [custom formats](/docs/usage/plugin#formats-custom), looked like a perfect fit to also precompile messages ahead of time.

So it was time to get to work.

## Challenges with precompilation

When compiling a simple message like `Hello {name}!`, you might get the following AST as a result:

```json
[
  {"type": 0, "value": "Hello "},
  {"type": 1, "value": "name"},
  {"type": 0, "value": "!"}
]
```

And while the compilation work is already done, the size of the AST data structure is significantly larger than our initial message. So while it takes away work from the runtime, it adds weight to the bundle.

Another approach is to compile messages into functions, like this:

```tsx
function hello(name: string) {
  return `Hello ${name}!`;
}
```

The problem with this approach however is that they can not be serialized across the RSC bridge when being passed to Client Components. Libraries that use this approach therefore resort to importing the generated function into components to avoid cross the bridge.

However, this results in all locale-specific variants being bundled with your code, therefore defeating the possibility to split messages by locale.

`next-intl` is used by websites like [Ethereum.org](https://ethereum.org), which currently ships in 67 languages. So the function-based approach is just not an option here.

## Minified ASTs

Architecturally, precompiled ASTs are a better fit for `next-intl`—but they were too large.

The core idea of Jan Nicklas's prototype was to minify the ASTs, largely avoiding object properties in favor of arrays with positional entries.

All of the heavy lifting is handled by a new library called [`icu-minify`](https://github.com/amannn/next-intl/tree/main/packages/icu-minify), which `next-intl` now depends on.

Messages get compiled to a minimal JSON representation at build time:

```tsx
compile('Hello {name}!');
```

… becomes:

```json
["Hello ", ["name"], "!"]
```

And from here, a minimal runtime takes over to evaluate the message—weighing in at just **650 bytes**.

## One flag

The good news is that this is built right into `next-intl`. There's no new API to learn. Just flip a switch:

```tsx filename="next.config.ts"
import createNextIntlPlugin from 'next-intl/plugin';

const withNextIntl = createNextIntlPlugin({
  messages: {
    path: './messages',
    locales: 'infer',
    format: 'json',

    // Enable precompilation
    precompile: true
  }
});

export default withNextIntl();
```

That's it. Your existing code using `useTranslations` and `useExtracted` will automatically benefit from this optimization. No code changes needed.

## Why this matters

There are two big wins here:

**1. Bundle size**

The ICU parser adds approximately 15KB (minified + compressed) to your bundle for both server and client. With precompilation, that's gone.

Adding a single translated string to a Client Component used to cost you [X KB]. With precompilation, it's [Y KB].

**2. Runtime performance**

Every message used to be parsed before it could be formatted. Parse results are cached, but total blocking time on initial page load can still be affected. Now, messages are just evaluated—no parsing overhead at all.

But perhaps the biggest win is the freedom. You can now use translations on the client without feeling like you're playing "the floor is lava." Use `useTranslations` in Client Components. Pass translated strings around. Structure your code the way that makes sense, not the way that avoids shipping the parser.

## How it works

For the curious, here's what's happening under the hood.

All of the heavy lifting is handled by a new library called [`icu-minify`](https://github.com/amannn/next-intl/tree/main/packages/icu-minify), which `next-intl` now depends on.

Messages get compiled to a minimal JSON representation at build time:

```tsx
compile('Hello {name}!');
```

… becomes:

```json
["Hello ", ["name"], "!"]
```

And from here, a minimal runtime takes over to evaluate the message—weighing in at just **650 bytes**.

Plain strings stay plain strings—no overhead at all. Complex messages with plurals, selects, rich text? They all compile to this compact format. And since it's plain JSON, it crosses the RSC bridge without any issues.

The compilation happens via a new library called `icu-minify`, which is part of the `next-intl` ecosystem. During the build, your message catalogs are transformed from ICU strings to this intermediate representation. At runtime, `next-intl` swaps out the traditional parser with `icu-minify`'s tiny runtime.

For the full details on the compiled format, see the [RFC](https://github.com/amannn/next-intl/blob/main/rfcs/002-icu-message-precompilation.md).

---

## Tradeoffs

Let me be upfront about the limitations.

`t.raw` is not supported with precompilation. Messages are parsed at build time, before we know if you'll call `t.raw` on them. If you try to use `t.raw` with precompiled messages, you'll get the intermediate representation instead of the raw string.

Historically, `t.raw` was added to support raw HTML content in messages. But time has shown there are better alternatives:

1. **MDX for local content**: For content like imprint pages, grouping your localized content into files like `content.en.mdx` and `content.es.mdx` is significantly easier to manage.
2. **CMS for remote content**: Content management systems typically ship with portable formats that express rich text in an HTML-agnostic way (see e.g. [Sanity's Portable Text](https://www.sanity.io/docs/developer-guides/presenting-block-text)).

If you rely heavily on `t.raw`, you can leave precompilation off for now. For more details on the tradeoffs, see the [RFC](https://github.com/amannn/next-intl/blob/main/rfcs/002-icu-message-precompilation.md#tradeoffs).

---

## Ready to try it?

If you're excited about this as well, I'd really love to hear your feedback.

Give it a try in your app with `next-intl@X.X` and share your [feedback](https://github.com/amannn/next-intl/discussions/XXXX) with me. Please note that it's currently considered experimental, so changes should be expected.

Also, it's worth mentioning again that the existing APIs you might be using today are not going anywhere. If you're already happy with how things work, then by all means keep using them. Personally, I think precompilation has a lot of potential, especially for apps with sensitive performance requirements.

Looking into auto-splitting messages to the client—more optimizations to come.

— Jan

PS: A special thank you to [Jan Nicklas](https://x.com/jantimon) for the original [icu-to-json](https://github.com/jantimon/icu-to-json) prototype that sparked this idea. I later discovered that [Lingui](https://lingui.dev/) also explored a similar approach with `@lingui/message-utils`—I was able to take the best parts of these and optimize further.

**Further reading:**

- [Message precompilation docs](/docs/usage/precompilation)
- [Next.js plugin docs](/docs/usage/plugin)
- [RFC: ICU Message Precompilation](https://github.com/amannn/next-intl/blob/main/rfcs/002-icu-message-precompilation.md)

<StayUpdated />
