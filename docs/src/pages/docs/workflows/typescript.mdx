import Details from '@/components/Details';
import {Tabs} from 'nextra/components';
import Callout from '@/components/Callout';

# TypeScript augmentation

`next-intl` integrates seamlessly with TypeScript right out of the box, requiring no additional setup.

However, you can optionally provide supplemental definitions to augment the types that `next-intl` works with, enabling improved autocompletion and type safety across your app.

```tsx filename="global.d.ts"
declare module 'next-intl' {
  interface AppConfig {
    // ...
  }
}
```

Type augmentation is available for:

- [`Messages`](#messages)
- [`Formats`](#formats)
- [`Locale`](#locale)

## `Messages`

Messages can be strictly typed to ensure you're using valid keys.

```json filename="messages.json"
{
  "About": {
    "title": "Hello"
  }
}
```

```tsx
function About() {
  // ✅ Valid namespace
  const t = useTranslations('About');

  // ✖️ Unknown message key
  t('description');

  // ✅ Valid message key
  t('title');
}
```

To enable this validation, you can adapt `AppConfig` as follows:

```ts filename="global.d.ts"
import messages from './messages/en.json';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Messages: typeof messages;
  }
}
```

You can freely define the interface, but if you have your messages available locally, it can be helpful to automatically create the type based on the messages from your default locale.

### Strict arguments [#messages-arguments]

Apart from strictly typing message keys, you can also ensure type safety for message arguments:

```json filename="messages/en.json"
{
  "UserProfile": {
    "title": "Hello {firstName}"
  }
}
```

```tsx
function UserProfile({user}) {
  const t = useTranslations('UserProfile');

  // ✖️ Missing argument
  t('title');

  // ✅ Argument is provided
  t('title', {firstName: user.firstName});
}
```

TypeScript currently has a [limitation](https://github.com/microsoft/TypeScript/issues/32063) where it infers the types of an imported JSON module as rather broad.

Due to this, `next-intl` provides a stopgap solution that allows you to generate an accompanying `.d.json.ts` file for the messages that you're assigning to your `AppConfig`.

**Usage:**

1. Enable the `createMessagesDeclaration` setting in your Next.js config:

```tsx filename="next.config.mjs"
import {createNextIntlPlugin} from 'next-intl/plugin';

const withNextIntl = createNextIntlPlugin({
  experimental: {
    // Use the path to the messages that you're using in `AppConfig`
    createMessagesDeclaration: './messages/en.json'
  }
});

// ...
```

2. Add support for JSON type declarations:

```json filename="tsconfig.json"
{
  "compilerOptions": {
    // ...
    "allowArbitraryExtensions": true
  }
}
```

With this setup in place, you'll see a new declaration file generated in your `messages` directory once you run `next dev` or `next build`:

```diff
  messages/en.json
+ messages/en.d.json.ts
```

This declaration file will provide the exact types for the messages that you're using in `AppConfig`, enabling type safety for message arguments.

You can choose to ignore this file in Git:

```text filename=".gitignore"
messages/*.d.json.ts
```

Please consider upvoting [microsoft/TypeScript#32063](https://github.com/microsoft/TypeScript/issues/32063) so that we can hopefully remove this workaround in the future.

## `Formats`

If you're using [global formats](/docs/usage/configuration#formats), you can strictly type the format names that are referenced in calls to `format.dateTime`, `format.number` and `format.list`.

```tsx
function Component() {
  const format = useFormatter();

  // ✖️ Unknown format string
  format.dateTime(new Date(), 'unknown');

  // ✅ Valid format
  format.dateTime(new Date(), 'short');

  // ✅ Valid format
  format.number(2, 'precise');

  // ✅ Valid format
  format.list(['HTML', 'CSS', 'JavaScript'], 'enumeration');
}
```

To enable this validation, export the formats that you're using e.g. from your request configuration:

```ts filename="i18n/request.ts"
import {Formats} from 'next-intl';

export const formats = {
  dateTime: {
    short: {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    }
  },
  number: {
    precise: {
      maximumFractionDigits: 5
    }
  },
  list: {
    enumeration: {
      style: 'long',
      type: 'conjunction'
    }
  }
} satisfies Formats;

// ...
```

Now, you can include the `formats` in your `AppConfig`:

```ts filename="global.d.ts"
import {formats} from '@/i18n/request';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Formats: typeof formats;
  }
}
```

## `Locale`

Augmenting the `Locale` type will affect the return type of [`useLocale`](/docs/usage/configuration#locale), as well as all `locale` arguments that are accepted by APIs from `next-intl` (e.g. the `locale` prop of [`<Link />`](/docs/routing/navigation#link)).

```tsx
// ✅ 'en' | 'de'
const locale = useLocale();
```

To enable this validation, you can adapt `AppConfig` as follows:

<Tabs items={['With i18n routing', 'Without i18n routing']}>
<Tabs.Tab>

```tsx filename="global.d.ts"
import {routing} from '@/i18n/routing';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Locale: (typeof routing.locales)[number];
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```tsx filename="global.d.ts"
// Potentially imported from a shared config
const locales = ['en', 'de'] as const;

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Locale: (typeof locales)[number];
  }
}
```

</Tabs.Tab>
</Tabs>

### Using the `Locale` type for arguments

Once the `Locale` type is augmented, it can be used across your codebase if you need to pass the locale to functions outside of your components:

```tsx {1,10}
import {Locale} from 'next-intl';
import {getLocale} from 'next-intl/server';

async function BlogPosts() {
  const locale = await getLocale();
  const posts = await getPosts(locale);
  // ...
}

async function getPosts(locale: Locale) {
  // ...
}
```

### Using the `Locale` type for layout and page params [#locale-segment-params]

You can also use the `Locale` type when working with the `[locale]` parameter in layouts and pages:

```tsx filename="app/[locale]/page.tsx"
import {Locale} from 'next-intl';

type Props = {
  params: {
    locale: Locale;
  };
};

export default function Page(props: Props) {
  // ...
}
```

However, keep in mind that this _assumes_ the locale to be valid in this place—Next.js doesn't validate the `[locale]` parameter automatically for you. Due to this, you can add your own validation logic in a central place like the root layout:

```tsx filename="app/[locale]/layout.tsx"
import {hasLocale} from 'next-intl';

// Can be imported e.g. from `@/i18n/routing`
const locales = ['en', 'de'] as const;

type Props = {
  params: {
    children: React.ReactNode;
    locale: string;
  };
};

export default async function LocaleLayout({params: {locale}}: Props) {
  if (!hasLocale(locales, locale)) {
    notFound();
  }

  // ✅ 'en' | 'de'
  console.log(locale);
}
```

## Troubleshooting

If you're encountering problems, double check that:

1. The interface uses the correct name `AppConfig`.
2. You're using correct paths for all modules you're importing into your global declaration file.
3. Your type declaration file is included in `tsconfig.json`.
4. Your editor has loaded the latest types. When in doubt, restart your editor.
