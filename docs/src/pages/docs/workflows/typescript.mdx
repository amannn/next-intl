import Details from '@/components/Details';
import {Tabs} from 'nextra/components';
import Callout from '@/components/Callout';

# TypeScript augmentation

`next-intl` integrates seamlessly with TypeScript right out of the box, requiring no additional setup.

However, you can optionally provide supplemental definitions to augment the types that `next-intl` works with, enabling improved autocompletion and type safety across your app.

```tsx filename="global.d.ts"
declare module 'next-intl' {
  interface AppConfig {
    // ...
  }
}
```

Type augmentation is available for:

- [`Messages`](#messages)
- [`Formats`](#formats)
- [`Locale`](#locale)

## `Messages`

Messages can be strictly typed to ensure you're using valid keys.

```json filename="messages.json"
{
  "About": {
    "title": "Hello"
  }
}
```

```tsx
function About() {
  // ✅ Valid namespace
  const t = useTranslations('About');

  // ✖️ Unknown message key
  t('description');

  // ✅ Valid message key
  t('title');
}
```

To enable this validation, you can adapt `AppConfig` as follows:

```ts filename="global.d.ts"
import en from './messages/en.json';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Messages: typeof en;
  }
}
```

You can freely define the interface, but if you have your messages available locally, it can be helpful to automatically create the type based on the messages from your default locale.

## `Formats`

If you're using [global formats](/docs/usage/configuration#formats), you can strictly type the format names that are referenced in calls to `format.dateTime`, `format.number` and `format.list`.

```tsx
function Component() {
  const format = useFormatter();

  // ✖️ Unknown format string
  format.dateTime(new Date(), 'unknown');

  // ✅ Valid format
  format.dateTime(new Date(), 'short');

  // ✅ Valid format
  format.number(2, 'precise');

  // ✅ Valid format
  format.list(['HTML', 'CSS', 'JavaScript'], 'enumeration');
}
```

To enable this validation, export the formats that you're using in your request configuration:

```ts filename="i18n/request.ts"
import {Formats} from 'next-intl';

export const formats = {
  dateTime: {
    short: {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    }
  },
  number: {
    precise: {
      maximumFractionDigits: 5
    }
  },
  list: {
    enumeration: {
      style: 'long',
      type: 'conjunction'
    }
  }
} satisfies Formats;

// ...
```

Now, you can include the `formats` in your `AppConfig`:

```ts filename="global.d.ts"
import {formats} from '@/i18n/request';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Formats: typeof formats;
  }
}
```

## `Locale`

Augmenting the `Locale` type will affect the return type of [`useLocale`](/docs/usage/configuration#locale), as well as all `locale` arguments that are received by `next-intl` (e.g. the `locale` prop of [`<Link />`](/docs/routing/navigation#link)).

```tsx
// ✅ 'en' | 'de'
const locale = useLocale();
```

To enable this validation, you can adapt `AppConfig` as follows:

<Tabs items={['With i18n routing', 'Without i18n routing']}>
<Tabs.Tab>

```tsx filename="global.d.ts"
import {routing} from '@/i18n/routing';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Locale: (typeof routing.locales)[number];
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```tsx filename="global.d.ts"
// Potentially imported from a shared config
const locales = ['en', 'de'] as const;

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Locale: (typeof locales)[number];
  }
}
```

</Tabs.Tab>
</Tabs>

### Using the `Locale` type for arguments

Once the `Locale` type is augmented, it can be used across your codebase if you need to pass the locale to functions outside of your components:

```tsx {2,10}
import {getLocale} from 'next-intl/server';
import {Locale} from 'next-intl';

async function BlogPosts() {
  const locale = await getLocale();
  const posts = await getPosts(locale);
  // ...
}

async function getPosts(locale: Locale) {
  // ...
}
```

### Using the `Locale` type for layout and page params [#locale-segment-params]

You can also use the `Locale` type when working with the `[locale]` parameter in layouts and pages:

```tsx filename="app/[locale]/page.tsx"
import {Locale} from 'next-intl';

type Props = {
  params: {
    locale: Locale;
  };
};

export default function Page(props: Props) {
  // ...
}
```

However, keep in mind that this _assumes_ the locale to be valid in this place—Next.js doesn't validate the `[locale]` parameter automatically for you. Due to this, you can add your own validation logic in a central place like the root layout:

```tsx filename="app/[locale]/layout.tsx"
import {isValidLocale} from 'next-intl';

// Can be imported e.g. from `@/i18n/routing`
const locales = ['en', 'de'] as const;

type Props = {
  params: {
    children: React.ReactNode;
    locale: string;
  };
};

export default async function LocaleLayout({params: {locale}}: Props) {
  if (!isValidLocale(locales, locale)) {
    notFound();
  }

  // ✅ 'en' | 'de'
  console.log(locale);
}
```

## Troubleshooting

If you're encountering problems, double check that:

1. Your interface uses the correct name.
2. You're using correct paths for all modules you're importing into your global declaration file.
3. Your type declaration file is included in `tsconfig.json`.
4. Your editor has loaded the most recent type declarations. When in doubt, you can restart.
