import Details from '@/components/Details';
import {Tabs} from 'nextra/components';
import Callout from '@/components/Callout';

# TypeScript augmentation

`next-intl` integrates seamlessly with TypeScript right out of the box, requiring no additional setup.

However, you can optionally provide supplemental definitions to augment the types that `next-intl` works with, enabling improved autocompletion and type safety across your app.

```tsx filename="global.d.ts"
import {routing} from '@/i18n/routing';
import {formats} from '@/i18n/request';
import messages from './messages/en.json';

declare module 'next-intl' {
  interface AppConfig {
    Locale: (typeof routing.locales)[number];
    Messages: typeof messages;
    Formats: typeof formats;
  }
}
```

Type augmentation is available for:

- [`Locale`](#locale)
- [`Messages`](#messages)
- [`Formats`](#formats)

## `Locale`

Augmenting the `Locale` type will affect all APIs from `next-intl` that either return or receive a locale:

```tsx
import {useLocale} from 'next-intl';

// ✅ 'en' | 'de'
const locale = useLocale();
```

```tsx
import {Link} from '@/i18n/routing';

// ✅ Passes the validation
<Link href="/" locale="en" />;
```

Additionally, `next-intl` provides a [`Locale`](/docs/usage/configuration#locale-type) type that can be used when passing the locale as an argument.

To enable this validation, you can adapt `AppConfig` as follows:

<Tabs items={['With i18n routing', 'Without i18n routing']}>
<Tabs.Tab>

```tsx filename="global.d.ts"
import {routing} from '@/i18n/routing';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Locale: (typeof routing.locales)[number];
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```tsx filename="global.d.ts"
// Potentially imported from a shared config
const locales = ['en', 'de'] as const;

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Locale: (typeof locales)[number];
  }
}
```

</Tabs.Tab>
</Tabs>

## `Messages`

Messages can be strictly typed to ensure you're using valid keys.

```json filename="messages.json"
{
  "About": {
    "title": "Hello"
  }
}
```

```tsx
function About() {
  // ✅ Valid namespace
  const t = useTranslations('About');

  // ✖️ Unknown message key
  t('description');

  // ✅ Valid message key
  t('title');
}
```

To enable this validation, you can adapt `AppConfig` as follows:

```ts filename="global.d.ts"
import messages from './messages/en.json';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Messages: typeof messages;
  }
}
```

You can freely define the interface, but if you have your messages available locally, it can be helpful to automatically create the type based on the messages from your default locale.

### Strict arguments [#messages-arguments]

Apart from strictly typing message keys, you can also ensure type safety for message arguments:

```json filename="messages/en.json"
{
  "UserProfile": {
    "title": "Hello {firstName}"
  }
}
```

```tsx
function UserProfile({user}) {
  const t = useTranslations('UserProfile');

  // ✖️ Missing argument
  t('title');

  // ✅ Argument is provided
  t('title', {firstName: user.firstName});
}
```

TypeScript currently has a [limitation](https://github.com/microsoft/TypeScript/issues/32063) where it infers the types of an imported JSON module as rather wide. Due to this, `next-intl` provides a stopgap solution that allows you to generate an accompanying `.d.json.ts` file for the messages that you're assigning to your `AppConfig`.

**Usage:**

1. Enable the `createMessagesDeclaration` setting in your Next.js config:

```tsx filename="next.config.mjs"
import {createNextIntlPlugin} from 'next-intl/plugin';

const withNextIntl = createNextIntlPlugin({
  experimental: {
    // Use the path to the messages that you're using in `AppConfig`
    createMessagesDeclaration: './messages/en.json'
  }
  // ...
});

// ...
```

2. Add support for JSON type declarations in your `tsconfig.json`:

```json filename="tsconfig.json"
{
  "compilerOptions": {
    // ...
    "allowArbitraryExtensions": true
  }
}
```

With this setup in place, you'll see a new declaration file generated in your `messages` directory once you run `next dev` or `next build`:

```diff
  messages/en.json
+ messages/en.d.json.ts
```

This declaration file will provide the exact types for the messages that you're using in `AppConfig`, enabling type safety for message arguments.

To keep your code base tidy, you can ignore this file in Git:

```text filename=".gitignore"
messages/*.d.json.ts
```

Please consider upvoting [`TypeScript#32063`](https://github.com/microsoft/TypeScript/issues/32063) to potentially remove this workaround in the future.

## `Formats`

If you're using [global formats](/docs/usage/configuration#formats), you can strictly type the format names that are referenced in calls to `format.dateTime`, `format.number` and `format.list`.

```tsx
function Component() {
  const format = useFormatter();

  // ✖️ Unknown format string
  format.dateTime(new Date(), 'unknown');

  // ✅ Valid format
  format.dateTime(new Date(), 'short');

  // ✅ Valid format
  format.number(2, 'precise');

  // ✅ Valid format
  format.list(['HTML', 'CSS', 'JavaScript'], 'enumeration');
}
```

To enable this validation, export the formats that you're using e.g. from your request configuration:

```ts filename="i18n/request.ts"
import {Formats} from 'next-intl';

export const formats = {
  dateTime: {
    short: {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    }
  },
  number: {
    precise: {
      maximumFractionDigits: 5
    }
  },
  list: {
    enumeration: {
      style: 'long',
      type: 'conjunction'
    }
  }
} satisfies Formats;

// ...
```

Now, you can include the `formats` in your `AppConfig`:

```ts filename="global.d.ts"
import {formats} from '@/i18n/request';

declare module 'next-intl' {
  interface AppConfig {
    // ...
    Formats: typeof formats;
  }
}
```

## Troubleshooting

If you're encountering problems, double check that:

1. The interface uses the correct name `AppConfig`.
2. You're using correct paths for all modules you're importing into your global declaration file.
3. Your type declaration file is included in `tsconfig.json`.
4. Your editor has loaded the latest types. When in doubt, restart your editor.
