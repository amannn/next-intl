import PartnerContentLink from 'components/PartnerContentLink';

# Design principles

This page provides insights about the design decisions that were made for `next-intl` in order to help you understand if this library aligns with your expectations and is a good fit for your project.

This list also serves as a transparent reference for areas that are still being worked on for `next-intl` to realize its full potential.

## Holistic

Internationalization clearly requires flexibility from your codebase. However, even implementing a single language properly can already be a challenge by itself.

Using **dynamic text labels** are the most obvious aspect of internationalization, but supporting a language really well also involves the following aspects:
1. **Pluralization rules**: While a language like English has only two plural forms (singular and plural), other languages have up to six different forms.
2. **Date and time formatting**: Different languages have different conventions for formatting dates and times. While the Gregorian calendar is used in most parts of the world, countries like Thailand use the Buddhist calendar, which is 543 years ahead of the Gregorian one.
3. **Number formatting**: Number formatting conventions vary across different languages. For instance, in English, the decimal separator is a period, whereas in German, it is a comma.
4. **Text direction**: While most languages are written from left to right, some languages like Arabic are written from right to left.
5. **List formatting**: Formatting lists like "HTML, CSS, and JavaScript" is not only a matter of assembling strings in the right order, but also of using the right conjunctions and punctuation marks.

On top of this come typical app problems like:
1. **Rich text formatting**: Many apps need to embed rich text into sentences (e.g. "Learn more in [the rich text docs](/docs/usage/messages#rich-text).").
2. **Time zones**: Displaying dates requires consistent handling of time zones across the server and client, potentially even customized based on a preference set by the user.
3. **Relative time formatting**: Displaying relative times like "5 minutes ago" or "in 2 hours" requires special care to get the formatting right. Potentially, you also need a mechanism to update the displayed time regularly.
4. **Unique URLs**: Providing unique URLs that match the user's language preference (e.g. `/en/about-us` for English and `/es/sobre-nosotros` for Spanish) is crucial for the user experience as well as SEO.

Considering this list, you might agree that internationalization is quite an interconnected topic. `next-intl` takes a holistic approach to internationalization that nudges you towards best practices for handling languages well. This way, you have more time to focus on what makes your app unique.

**Area of improvement**: In regard to URL handling, `next-intl` currently works well with locale prefixes (e.g. `/en` or `/pt-BR`), and domain-based routing (e.g. `en.example.com`). However, `next-intl` should have built-in support for a mapping between custom prefixes and locales (e.g. `/uk` → `/en-UK`, see [#653](https://github.com/amannn/next-intl/issues/653)).

## Ergonomic

The bold claim of this library is that your app code will become simpler instead of more complex when you implement internationalization.

If you consider [the holistic picture](/docs/design-principles#holistic) of what internationalization entails, it's clear that a majority of your components will be involved with internationalization in one way or another. Due to this, `next-intl` makes it a priority to provide convenient APIs that are ensure you feel productive and in control. 

Once internationalization is set up, adding a new language should be as simple as adding a new JSON file with translations. For app-specific code, `next-intl` utilizes TypeScript, e.g. to ensure you've declared localized pathnames for all locales (in case you're using this feature).

**Areas of improvement**:
 - While handling multiple languages is the common case, `next-intl` is also expected to work well for apps that only support a single language. After all, if using internationalization right from the start is easier than hardcoding text and formatting, then this should be a common workflow. The Pages Router integration was already capable of this, but ideally we support this similarly for the App Router as well (see [#960](https://github.com/amannn/next-intl/issues/960)).
 - With the introduction of Server Components, it became a difference in regard to [performance](#performance-obsessed) which messages are made available to the client and which are only used on the server side. The situation is arguably already good for apps that require messages either only on the server or the client side, or those where removing server-only messages is not a priority, but we could improve the ergonomics for apps where it's common to split messages in a granular way (see [Providing individual messages to Client Components](/docs/environments/server-client-components#option-3-providing-individual-messages) and [#1](https://github.com/amannn/next-intl/issues/1)).

## Standards-based

With the introduction of [the ECMAScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl), JavaScript has gotten very capable in the recent years in regard to formatting of dates, times, numbers, lists and pluralization. `next-intl` builds on top of this API and provides an ergonomic interface to work with these features, while considering your app-specic configuration & needs.

For text formatting, `next-intl` is based on [International Components for Unicode (ICU)](https://unicode-org.github.io/icu/userguide/format_parse/). ICU is a mature and widely used standard for internationalization that is supported by many programming languages and frameworks. `next-intl` uses the ICU message syntax for defining text labels, which allows to express complex text formatting requirements like interpolating variables and pluralization in a concise and readable way—also to translators.

By being based on standards, `next-intl` ensures that your internationalization code is future-proof and feels familiar to developers who have exisiting experience with internationalization. Additionally, relying on standards ensures that `next-intl` integrates well with translation management systems like <PartnerContentLink href="https://crowdin.com/">Crowdin</PartnerContentLink>.

`next-intl` uses a [nested style](/docs/usage/messages#structuring-messages) to provide structure to messages, allowing to express hierarchies of messages without redundancy. By supporting only a single style, we can offer advanced features that rely on these assumptions like [type-safety for messages](/docs/workflows/typescript). If you're coming from a different style, you can consider migrating to the nested style (see "Can I use another style for structuring my messages?" in [the structuring messages docs](/docs/usage/messages#structuring-messages)).

As standards can change, `next-intl` is expected to keep up with the latest developments in the ECMAScript standard (e.g. [`Temporal`](https://tc39.es/proposal-temporal/docs/) and [`Intl.MessageFormat`](https://github.com/tc39/proposal-intl-messageformat)).

## Performance-obsessed

`next-intl` was designed with high-traffic sites in mind that need to deliver a fast and reliable user experience. The library has proven to work on complex e-commerce pages with a Lighthouse performance score of >95.

To achieve this, `next-intl` primarly relies on these techniques currently:
1. **RSC-first**: By integrating deeply with React Server Components, we can offload work to a build step or a capable server, and therefore reduce the runtime footprint of your app.
2. **Caching**: Formatting of messages is cached. Therefore if components are re-rendered with the same data, the previous formatting result can be reused.
3. **Shortcuts**: By detecting plain messages, these messages can be returned immediately without having to parse them first.
4. **Splitting of messages**: By splitting messages by locale, server, client and component, we can reduce the amount of messages that are sent to the client. This is especially important for apps that support many languages and have a large amount of messages.

**Areas of improvement**:
 - It's being evaluated if messages can be compiled ahead of time, no longer requiring to load an ICU parser on the client side (see [#705](https://github.com/amannn/next-intl/pull/705)).
 - Caching of `Intl.*` constructors for the `useFormatter` API is under investigation, but has generally improved in modern JavaScript runtimes (see [#215](https://github.com/amannn/next-intl/issues/215)).

## Integratable

While `next-intl` is designed to tackle internationalization in [a holistic way](#holistic), it's important to consider that internationalization might require integration with other tools and services, enabling you to use the best tools for the job and to collaborate with non-developers.

There are two primary services that are often used in conjunction with `next-intl`:

### Translation Management Systems (TMS)

These are typically used to manage translations and to [collaborate with translators](/docs/workflows/localization-management). Services like <PartnerContentLink href="https://crowdin.com/">Crowdin</PartnerContentLink> provide a wide range of features, allowing translators to work in a web-based interface on translations, while providing different mechanisms to sync translations with your app.

`next-intl` integrates well with these services, as it uses the ICU message syntax for defining text labels, which is a widely supported standard. This allows you to export messages from `next-intl` in a format that can be imported into a TMS, and to import translations from a TMS back into `next-intl`. While it's recommended to have at least the messages for the default locale available locally (e.g. for [type-safe messages](/docs/workflows/typescript)), you can also load messages dynamically, e.g. from a CDN that your TMS provides.

### Content Management Systems (CMS)

If your app uses content from a CMS, you can use this alongside `next-intl`. For instance, you might want to manage content like blog posts, or marketing copy in a CMS, while managing UI labels in `next-intl`.

A CMS typically provides a way to define content for multiple languages, and to fetch this content via a REST API. By using the negotiated app locale that is returned from `next-intl` via [`getLocale`](/docs/environments/server-client-components#async-components) and passing it to requests to your CMS API, you can retrieve content for the user's preferred language.
