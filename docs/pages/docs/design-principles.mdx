import PartnerContentLink from 'components/PartnerContentLink';

# Design principles

This page provides insights about the design decisions that were made for `next-intl` in order to help you understand if this library aligns with your expectations and is a good fit for your project.

This also serves as a transparent reference for areas that are still being worked on for `next-intl` to realize its full potential.

## Holistic

Internationalization clearly requires flexibility from your codebase. However, even implementing a single language properly can already be a challenge by itself.

Using **dynamic text labels** are the most obvious aspect of internationalization, but supporting a language well also involves the following aspects:
1. **Pluralization rules**: While a language like English has only two plural forms (singular and plural), other languages have up to six different forms.
2. **Date and time formatting**: Different languages have different conventions for formatting dates and times. Even the year displayed can vary from country to country; for example, Thailand uses the Buddhist calendar, which is 543 years ahead of the Gregorian calendar.
3. **Number formatting**: Number formatting conventions vary across different languages. For instance, in English, the decimal separator is a period, whereas in German, it is a comma.
4. **Text direction**: While most languages are written from left to right, some languages like Arabic are written from right to left.
5. **List formatting**: Formatting lists like "HTML, CSS, and JavaScript" is not only a matter of assembling strings in the right order, but also of using the right conjunctions and punctuation marks.

On top of this come typical app problems like:
1. **Rich text formatting**: Many apps need to embed rich text into sentences (e.g. "Learn more in [the rich text docs](/docs/usage/messages#rich-text).").
2. **Time zones**: Displaying dates requires consistent handling of time zones across the server and client, potentially even customized based on a preference of the user.
3. **Relative time formatting**: Displaying relative times like "5 minutes ago" or "in 2 hours" requires special care to get the formatting right, and also to make sure the rendered result is in sync across the server and client. Potentially, you also need a mechanism to update the displayed time regularly.
4. **Unique URLs**: Providing unique URLs that match the user's language preference is crucial for the user experience as well as SEO (e.g. `/en/about-us` for English and `/es/sobre-nosotros` for Spanish).

Considering this list, you might agree that internationalization is quite an interconnected topic.

`next-intl` takes a holistic approach to internationalization that nudges you towards best practices for handling languages and country-specific conventions. This way, you have more time to focus on what makes your app unique.

<details>
<summary>Areas of improvement</summary>

In regard to URL handling, `next-intl` currently works well with locale prefixes (e.g. `/en` or `/pt-BR`), and domain-based routing (e.g. `en.example.com`). However, `next-intl` should have built-in support for a mapping between custom prefixes and locales (e.g. `/uk` → `/en-UK`). Built-in support is being worked on in [#653](https://github.com/amannn/next-intl/issues/653), but workarounds are currently available.

</details>

## Ergonomic

The bold claim of this library is that your app code will become simpler instead of more complex when you implement internationalization.

If you consider [the holistic picture](/docs/design-principles#holistic) of what internationalization entails, it's clear that a majority of your components will be involved with internationalization in one way or another. Due to this, `next-intl` makes it a priority to provide convenient APIs that ensure you feel productive and in control. 

Once internationalization is set up, adding a new language is mostly a matter of adding a new JSON file with translations. Everything else is being taken care of by `next-intl`.

<details>
<summary>Areas of improvement</summary>

 - While handling multiple languages is the common case, `next-intl` is also expected to work well for apps that only support a single language. After all, if using internationalization right from the start is easier than hardcoding text and formatting, then this should be a common workflow. The Pages Router integration was already capable of this, but ideally we support this similarly for the App Router as well (see [#960](https://github.com/amannn/next-intl/issues/960)).
 - With the introduction of Server Components, it became a difference in regard to [performance](#performance-obsessed) which messages are made available to the client and which are only used on the server side. The situation is arguably already good for apps that require messages either only on the server or the client side, or those where removing server-only messages is not a priority, but we could improve the ergonomics for apps where it's common to split messages in a granular way. A compiler-driven approach is being explored in [#1](https://github.com/amannn/next-intl/issues/1).

</details>

## Standards-based

With the introduction of [the ECMAScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl), JavaScript has gotten very capable in the recent years in regard to formatting of dates, times, numbers, lists and pluralization. `next-intl` builds on top of this API and provides an ergonomic interface to work with these features, while considering your app-specic configuration & needs.

For text formatting, `next-intl` is based on [International Components for Unicode (ICU)](https://unicode-org.github.io/icu/userguide/format_parse/). ICU is a mature and widely used standard for internationalization that is supported by many programming languages and frameworks. `next-intl` uses the ICU message syntax for defining text labels, which allows to express complex text formatting requirements like interpolating variables and pluralization in a concise and readable way—also to translators.

By being based on standards, `next-intl` ensures that your internationalization code is future-proof and feels familiar to developers who have exisiting experience with internationalization. Additionally, relying on standards ensures that `next-intl` integrates well with translation management systems like <PartnerContentLink href="https://crowdin.com/">Crowdin</PartnerContentLink>.

`next-intl` uses a [nested style](/docs/usage/messages#structuring-messages) to provide structure to messages, allowing to express hierarchies of messages without redundancy. By supporting only a single style, we can offer advanced features that rely on these assumptions like [type-safety for messages](/docs/workflows/typescript). If you're coming from a different style, you can consider migrating to the nested style (see "Can I use another style for structuring my messages?" in [the structuring messages docs](/docs/usage/messages#structuring-messages)).

As standards can change, `next-intl` is expected to keep up with the latest developments in the ECMAScript standard (e.g. [`Temporal`](https://tc39.es/proposal-temporal/docs/) and [`Intl.MessageFormat`](https://github.com/tc39/proposal-intl-messageformat)).

## Performance-obsessed

`next-intl` was designed with high-traffic sites in mind that need to deliver a fast and reliable user experience. The library has proven to work on complex e-commerce pages with a Lighthouse performance score of >95.

To achieve this, `next-intl` primarly relies on these techniques currently:
1. **RSC-first**: By integrating deeply with React Server Components, we can offload work to a build step or a capable server, and therefore reduce the runtime footprint of your app.
2. **Caching**: Formatting of messages is cached. Therefore if components are re-rendered with the same data, the previous formatting result can be reused.
3. **Shortcuts**: By detecting plain messages, these messages can be returned immediately without having to parse them first.
4. **Splitting of messages**: By splitting messages by locale, server, client and component, we can reduce the amount of messages that are sent to the client. This is especially important for apps that support many languages and have a large amount of messages.

<details>
<summary>Areas of improvement</summary>

 - It's being evaluated if messages can be compiled ahead of time, no longer requiring to load an ICU parser on the client side (see [#705](https://github.com/amannn/next-intl/pull/705)).
 - Caching of `Intl.*` constructors for the `useFormatter` API is under investigation, but has generally improved in modern JavaScript runtimes (see [#215](https://github.com/amannn/next-intl/issues/215)).
 - To achieve static rendering, we currently utilize a [workaround](https://github.com/amannn/next-intl/issues/663). It works reliably, but we've [reached out to the Next.js team](https://github.com/vercel/next.js/discussions/58862) to hopefully remove this in the future.

</details>

## Integratable

While `next-intl` is designed to tackle internationalization in [a holistic way](#holistic), it's important to consider that internationalization might require integration with other tools and services, enabling you to use the best tools for the job and to collaborate with non-developers.

There are two primary services that are often used in conjunction with `next-intl`:

### Translation Management Systems (TMS)

These are typically used to manage translations and to [collaborate with translators](/docs/workflows/localization-management). Services like <PartnerContentLink href="https://crowdin.com/">Crowdin</PartnerContentLink> provide a wide range of features, allowing translators to work in a web-based interface on translations, while providing different mechanisms to sync translations with your app.

`next-intl` integrates well with these services, as it uses the ICU message syntax for defining text labels, which is a widely supported standard. This allows you to export messages from `next-intl` in a format that can be imported into a TMS, and to import translations from a TMS back into `next-intl`. While it's recommended to have at least the messages for the default locale available locally (e.g. for [type-safe messages](/docs/workflows/typescript)), you can also load messages dynamically, e.g. from a CDN that your TMS provides.

### Content Management Systems (CMS)

If your app uses content from a CMS, you can use this alongside `next-intl`. For instance, you might want to manage content like blog posts, or marketing copy in a CMS, while managing UI labels in `next-intl`.

A CMS typically provides a way to define content for multiple languages, and to fetch this content via a REST API. By using the negotiated app locale that is returned from `next-intl` via [`getLocale`](/docs/environments/server-client-components#async-components) and passing it to requests to your CMS API, you can retrieve content for the user's preferred language.

## Next.js-first

Next.js comes with a lot of bells and whistles, but at the same time there are a number of aspects that need to be handled carefully to enable a reliable internationalization integration. `next-intl`, as the name implies, is primarly designed to work well with Next.js. Rather than trying to be a one-size-fits-all solution, `next-intl` integrates with Next.js as deeply as necessary and makes it a priority to stay on top of the latest developments in the Next.js ecosystem.

That being said, `next-intl` has a Next.js-agnostic core that can be used in any React app, or even in plain JavaScript: [`use-intl`](/docs/environments/core-library). This core library contains most features of `next-intl`, but lacks Next.js-specific integrations like routing APIs. The goal of this library is to make it possibly to use familiar APIs in other parts of your stack (e.g. React Native) and to provide a straightforward way to [migrate away from Next.js](#ejectable), in case you ever decide to do so.

## Ejectable

We've all been there, technology moves on, and sometimes you need to move on as well. `next-intl` is designed to be a good citizen in your codebase, and to make it easy to migrate away from certain parts of your stack in case this becomes necessary.

If you ever feel like Next.js or `next-intl` is not the right fit for your project anymore, you have multiple options here:
1. **Moving away from Next.js**: If you decide to migrate away from Next.js, you can continue to use the core library [`use-intl`](/docs/environments/core-library) in any React app, e.g. allowing you to reuse existing components in a Remix app, or just plain React.
2. **Moving away from `next-intl`**: If you find that `next-intl` doesn't fit your needs anymore, you'll have to adapt app code that references the library, but you can still reuse your [standards-based](#standards-based) ICU messages and replace formatting APIs e.g. with direct calls to the [ECMAScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl).

We wont hold you back, but if you like, we can stay friends.

That being said, we're doing our best to make `next-intl` a good fit for your project. If you ever feel like something is not working as expected or if you have ideas for improvements, please let us know on the [issue tracker](https://github.com/amannn/next-intl/issues) and we'll do our best to help you out.

---

Woah, this was a long read. Did you really read all of this? `next-intl` was created out of a lot of curiosity and passion for internationalization, seems like we share that. We're always curious to hear how `next-intl` is working out for you. If you have any feedback or questions, please don't hesitate to [reach out](https://github.com/amannn/next-intl/discussions)!
