import Callout from 'components/Callout';

# TypeScript integration

`next-intl` integrates seamlessly with TypeScript right out of the box, requiring no additional setup. However, you can define the shape of your messages and global formats to enable autocompletion and type safety for your namespaces, message keys and global format strings.

## Messages

Enabling type safety for your messages allows for autocompletion and type checking of your message keys and namespaces. See the example below:

```json filename="messages.json"
{
  "About": {
    "title": "Hello"
  }
}
```

```tsx filename="About.tsx"
function About() {
  // ✅ Valid namespace
  const t = useTranslations('About');

  // ✖️ Unknown message key
  t('description');

  // ✅ Valid message key
  return <p>{t('title')}</p>;
}
```

To enable this validation, add a global type definition file in your project root (e.g. `global.d.ts`):

```ts filename="global.d.ts"
import en from './messages/en.json';

type Messages = typeof en;

declare global {
  // Use type safe message keys with `next-intl`
  interface IntlMessages extends Messages {}
}
```

You can freely define the interface, but if you have your messages available locally, it can be helpful to automatically create the interface based on the messages from your default locale by importing it.

**If you're encountering problems, please double check that:**

1. Your interface is called `IntlMessages`.
2. You're using TypeScript version 4 or later.
3. The path of your `import` is correct.
4. Your type declaration file is included in `tsconfig.json`.
5. Your editor has loaded the most recent type declarations. When in doubt, you can restart.

## Formats

`next-intl` provides a way to define [global formats](/docs/usage/configuration#formats) for your application. You can provide the type of your formats similarly to how you define the type of messages.

First, define your formats and export them from a file:

```ts filename="i18n/request.ts"
import {getRequestConfig} from 'next-intl/server';
import type {Formats} from 'next-intl';

export const formats = {
  dateTime: {
    short: {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    }
  },
  number: {
    precise: {
      maximumFractionDigits: 5
    }
  },
  list: {
    enumeration: {
      style: 'long',
      type: 'conjunction'
    }
  }
} satisfies Partial<Formats>;
 
export default getRequestConfig(async ({locale}) => {
  // ...
 
  return {
    formats,
  }
});
```

Then, in your `global.d.ts` at the root of your project, define the `IntlFormats` type:

```ts filename="global.d.ts"
import {formats} from './src/i18n/request'; 

type Formats = typeof formats;

declare global {
  // Use type safe formats with `next-intl`
  interface IntlFormats extends Formats {}
}
```

Now you will have full autocompletion and type safety for your formats:

```tsx filename="CurrentDate.tsx"
function Component() {
  const format = useFormatter();

  // ✅ Valid format
  format.number(2, "precise");

  // ✅ Valid format
  format.list(["some", "things"], "enumeration");

  // ✖️ Unknown format string
  format.dateTime(new Date(), "unknown")

  // ✅ Valid format
  return <p>{format.dateTime(new Date(), "short")}</p>;
}
```