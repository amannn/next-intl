import Callout from 'components/Callout';

# Internationalization of Server & Client Components in Next.js 13

With the introduction of the App Router in Next.js 13, [React Server Components](https://nextjs.org/docs/getting-started/react-essentials) became publicly available. This new paradigm allows components that don’t require React’s interactive features, such as `useState` and `useEffect`, to remain server-side only.

This applies to handling internationalization too.

```tsx filename="app/[locale]/page.tsx"
import {useTranslations} from 'next-intl';

// Since this component doesn't use any interactive features
// from React, it can be implemented as a Server Component.

export default function Index() {
  const t = useTranslations('Index');
  return <h1>{t('title')}</h1>;
}
```

Depending on if you import `useTranslations`, `useFormatter`, `useLocale`, `useNow` and `useTimeZone` from a Server or Client Component, `next-intl` will automatically provide an implementation that works best for the given environment.

<details>
<summary>Deep dive: How does the Server Components integration work?</summary>

`next-intl` uses [`react-server` conditional exports](https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md#react-server-conditional-exports) to load code that is optimized for the usage in Server or Client Components. While configuration for hooks like `useTranslations` is read via `useContext` on the client side, on the server side it is loaded via [`i18n.ts`](/docs/usage/configuration#i18nts).

Hooks are currently primarly known for being used in Client Components since they are typically stateful or don't apply to a server environment. However, hooks like [`useId`](https://react.dev/reference/react/useId) can be used in Server Components too. Similarly, `next-intl` uses a hooks-based API that looks identical, regardless of if it's used in a Server or Client Component. This allows to use hooks like `useTranslations` in [shared components](https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md#sharing-code-between-server-and-client), which can run both as a Server or a Client Component, depending on where they are imported from.

The one restriction that currently comes with this pattern is that hooks can not be called from `async` components. To resolve this,
you can split your component into two, leaving the async code in the first one and
moving the usage of the hook to the second one.

**Example:**

```tsx filename="app/[locale]/profile/page.tsx"
export default async function Profile() {
  // Use this component for all async code ...
  const user = await getUser();
  return <ProfileContent user={user} />;
}

function ProfileContent({user}) {
  // ... and use this one for rendering the fetched data
  const t = useTranslations('ProfileContent');
  return <p><{t('title', {userName: user.name})}/p>
}
```

As a benefit, the extracted component now works both in Server as well as Client Components, depending on where it is rendered.

For edge cases in server-only components, you can use [awaitable APIs from `next-intl`](/docs/environments/metadata-route-handlers).

</details>

## Benefits of handling i18n in Server Components [#server-components-benefits]

Moving internationalization to the server side unlocks new levels of performance, leaving the client side for interactive features.

<Callout emoji="✅" title="Benefits of server-side internationalization:">
  <ol className="ml-4 list-decimal">
    <li>
      Your messages never leave the server and don't need to be serialized for
      the client side
    </li>
    <li>
      Library code for internationalization doesn't need to be loaded on the
      client side
    </li>
    <li>No need to split your messages, e.g. based on routes or components</li>
    <li>No runtime cost on the client side</li>
    <li>
      No need to handle environment differences like different time zones on the
      server and client
    </li>
  </ol>
</Callout>

## Using internationalization in Client Components

Depending on your situation, you may need to handle internationalization in Client Components as well. There are several options for using translations or other functionality from `next-intl` in Client Components, listed here in order of recommendation.

### Option 1: Passing translations to Client Components

The preferred approach is to pass the processed labels as props or `children` from a Server Component.

```tsx filename="[locale]/faq/page.tsx" {7-9}
import {useTranslations} from 'next-intl';
import Expandable from './Expandable';

export default function FAQEntry() {
  const t = useTranslations('FAQEntry');
  return (
    <Expandable title={t('title')}>
      <FAQContent content={t('description')} />
    </Expandable>
  );
}
```

```tsx filename="Expandable.tsx" {5,14-15}
'use client';

import {useState} from 'react';

function Expandable({title, children}) {
  const [expanded, setExpanded] = useState(false);

  function onToggle() {
    setExpanded(!expanded);
  }

  return (
    <div>
      <button onClick={onToggle}>{title}</button>
      {expanded && <div>{children}</div>}
    </div>
  );
}
```

As you see, we can use interactive features from React like `useState` on translated content, even though the translation only runs on the server side.

Learn more in the Next.js docs: [Passing Server Components to Client Components as Props](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#supported-pattern-passing-server-components-to-client-components-as-props)

### Option 2: Moving state to the server side

You might run into cases where you have dynamic state, such as pagination, that should be reflected in translated messages.

```tsx filename="Pagination.tsx"
function Pagination({curPage, totalPages}) {
  const t = useTranslations('Pagination');
  return <p>{t('info', {curPage, totalPages})}</p>;
}
```

You can still manage your translations on the server side by using:

1. [Page or search params](https://nextjs.org/docs/app/api-reference/file-conventions/page)
2. [Cookies](https://nextjs.org/docs/app/api-reference/functions/cookies)
3. [Database state](https://nextjs.org/docs/app/building-your-application/data-fetching)

In particular, page and search params are often a great option because they offer additional benefits such as preserving the state of the app when the URL is shared, as well as integration with the browser history.

<Callout>
  There's [an article on Smashing Magazine about using `next-intl` in Server
  Components](https://www.smashingmagazine.com/2023/03/internationalization-nextjs-13-react-server-components)
  which explores the usage of search params through a real-world example
  (specifically [the section about adding
  interactivity](https://www.smashingmagazine.com/2023/03/internationalization-nextjs-13-react-server-components/#adding-interactivity-dynamic-ordering-of-photos)).
</Callout>

### Option 3: Providing individual messages

If you need to incorporate dynamic state that can not be moved to the server side, you can wrap the respective components with `NextIntlClientProvider`.

```tsx filename="Counter.tsx"
import pick from 'lodash/pick';
import {NextIntlClientProvider} from 'next-intl';
import ClientCounter from './ClientCounter';

export default function Counter() {
  // Receive messages provided in `i18n.ts`
  const messages = useMessages();

  return (
    <NextIntlClientProvider
      messages={
        // Only provide the minimum of messages
        pick(messages, 'ClientCounter')
      }
    >
      <ClientCounter />
    </NextIntlClientProvider>
  );
}
```

([working example](https://github.com/amannn/next-intl/blob/feat/next-13-rsc/examples/example-next-13-advanced/src/components/client/02-MessagesOnClientCounter/Counter.tsx))

<Callout>
  `NextIntlClientProvider` inherits the props `locale`, `now` and `timeZone`
  when the component is rendered from a Server Component. Other configuration
  properties like `messages` and `formats` can be provided as necessary.
</Callout>

### Option 4: Providing all messages

If you're building a highly dynamic app where most components use React's interactive features, you may prefer to make all messages available to Client Components.

```tsx filename="app/[locale]/layout.tsx" /NextIntlClientProvider/
import {NextIntlClientProvider} from 'next-intl';
import {notFound} from 'next/navigation';

export default async function LocaleLayout({children, params: {locale}}) {
  // ...

  // Receive messages provided in `i18n.ts`
  const messages = useMessages();

  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider locale={locale} messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
```

<Callout type="warning">
  Note that this is a tradeoff in regard to performance (see [the bullet points
  above](#server-components-benefits)).
</Callout>

## Troubleshooting

### "Failed to call `useTranslations` because the context from `NextIntlClientProvider` was not found." [#missing-context]

You might encounter this error or a similar one referencing `useFormatter` while working on your app.

This can happen because:

1. The component that calls the hook accidentally ended up in a client-side module graph, but you expected it to render as a Server Component. If this is the case, try to [pass this component via `children`](#option-1-passing-translations-to-client-components) to the Client Component instead.
2. You're intentionally calling the hook from a Client Component, but `NextIntlClientProvider` is not present as an ancestor in the component tree. If this is the case, you can [wrap your component in `NextIntlClientProvider`](#option-3-providing-individual-messages) to resolve this error.

### "Functions cannot be passed directly to Client Components because they're not serializable." [#non-serializable-props]

You might encounter this error when you try to pass a non-serializable prop to `NextIntlClientProvider`.

The component accepts the following props that are not serializable:

1. [`onError`](/docs/usage/configuration#error-handling)
2. [`getMessageFallback`](/docs/usage/configuration#error-handling)
3. Rich text elements for [`defaultTranslationValues`](/docs/usage/configuration#default-translation-values)

To configure these, you can wrap `NextIntlClientProvider` with another component that is marked with `'use client'` and defines the relevant props:

```tsx filename="MyCustomNextIntlClientProvider.tsx"
'use client';

import {NextIntlClientProvider} from 'next-intl';

export default function MyCustomNextIntlClientProvider({
  locale,
  timeZone,
  now,
  ...rest
}) {
  return (
    <NextIntlClientProvider
      // Define non-serializable props here
      defaultTranslationValues={{
        i: (text) => <i>{text}</i>
      }}
      // Make sure to forward these props to avoid markup mismatches
      locale={locale}
      timeZone={timeZone}
      now={now}
      {...props}
    />
  );
}
```

([working example](https://codesandbox.io/p/sandbox/next-intl-non-serializable-props-on-nextintlclientprovider-r0h2hi?file=%2Fsrc%2Fapp%2F%5Blocale%5D%2FNextIntlProvider.tsx))

By doing this, your custom provider will already be part of the client-side bundle and can therefore define and pass functions as props.

**Important:** Be sure to pass explicit `locale`, `timeZone` and `now` props to `NextIntlClientProvider` in this case, since the props aren't automatically inherited from a Server Component when you import `NextIntlClientProvider` from a Client Component.
