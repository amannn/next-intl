import Callout from 'components/Callout';

# Usage in Server Components (beta)

Next.js 13 introduces support for [React Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components) with the App Router. `next-intl` is adopting the new capabilities and is currently offering a beta version to early adopters, who are already building apps with the `app` directory.

<Callout type="warning">
  The App Router is currently in beta, patterns are still emerging and APIs may
  change. Please **use this at your own risk**, knowing that you might have to
  face a migration effort as the App Router becomes stable.
</Callout>

## Current beta version

```
npm install next-intl@2.13.0-beta.2
```

This beta version was tested with `next@13.2.4`.

## Roadmap

| Feature                                            | Status |
| :------------------------------------------------- | :----: |
| Usage of all `next-intl` APIs in Server Components |   ‚úÖ   |
| Middleware for i18n routing                        |   ‚úÖ   |
| Dynamic rendering                                  |   ‚úÖ   |
| Static rendering (i.e. `generateStaticParams`)     |   üèóÔ∏è   |

<Callout>
  While the support for static rendering is pending, consider [CDN
  caching](#cdn-caching) to get the same performance characteristics from
  dynamic rendering or [use Client Components](/docs/next-13/client-components)
  for the time being.
</Callout>

For details, see the [pending pull request for Server Components support](https://github.com/amannn/next-intl/pull/149).

## Getting started

If you haven't done so already, [create a Next.js 13 app that uses the App Router](https://beta.nextjs.org/docs/installation). All pages should be moved within a `[locale]` folder so that we can use this segment to provide content in different languages (e.g. `/en`, `/en/about`, etc.).

**Start by creating the following file structure:**

```
‚îú‚îÄ‚îÄ messages (1)
‚îÇ   ‚îú‚îÄ‚îÄ en.json
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ i18n.ts (2)
‚îú‚îÄ‚îÄ next.config.js (3)
‚îú‚îÄ‚îÄ middleware.ts (4)
‚îî‚îÄ‚îÄ app
    ‚îî‚îÄ‚îÄ [locale]
        ‚îú‚îÄ‚îÄ layout.tsx (5)
        ‚îî‚îÄ‚îÄ page.tsx (6)
```

**Now, set up the files as follows:**

<div className="steps">

### `messages/en.json`

Messages can be provided locally or loaded from a remote data source (e.g. a translation management system). Use whatever suits your workflow best.

The simplest option is to create JSON files locally based on locales, e.g. `en.json`.

```json filename="messages/en.json"
{
  "Index": {
    "title": "Hello world!"
  }
}
```

### `i18n.ts`

`next-intl` creates a configuration once per request and makes it available to all Server Components. Here you can provide messages depending the locale of the user.

```tsx filename="i18n.ts"
import {getRequestConfig} from 'next-intl/server';

export default getRequestConfig(async ({locale}) => ({
  messages: (await import(`./messages/${locale}.json`)).default
}));
```

### `next.config.js`

Now, set up the plugin and provide the path to your configuration.

```js filename="next.config.js"
const withNextIntl = require('next-intl/plugin')(
  // This is the default (also the `src` folder is supported out of the box)
  './i18n.ts'
);

module.exports = withNextIntl({
  // Other Next.js configuration ...
  experimental: {appDir: true}
});
```

### `middleware.ts`

The middleware matches a locale for the request and handles redirects and rewrites accordingly.

```tsx filename="middleware.ts"
import createMiddleware from 'next-intl/middleware';

export default createMiddleware({
  // A list of all locales that are supported
  locales: ['en', 'de'],

  // If this locale is matched, pathnames work without a prefix (e.g. `/about`)
  defaultLocale: 'en'
});

export const config = {
  // Skip all paths that should not be internationalized
  matcher: ['/((?!api|_next|.*\\..*).*)']
};
```

### `app/[locale]/layout.tsx`

The `locale` that was matched by the middleware is available via `useLocale` and can be used to configure the document language.

```tsx filename="app/[locale]/layout.tsx"
import {useLocale} from 'next-intl';
import {notFound} from 'next/navigation';

export default function LocaleLayout({children, params}) {
  const locale = useLocale();

  // Show a 404 error if the user requests an unknown locale
  if (params.locale !== locale) {
    notFound();
  }

  return (
    <html lang={locale}>
      <body>{children}</body>
    </html>
  );
}
```

### `app/[locale]/page.tsx`

Use translations in your page components or anywhere else!

```tsx filename="app/[locale]/page.tsx"
import {useTranslations} from 'next-intl';

export default function Index() {
  const t = useTranslations('Index');
  return <h1>{t('title')}</h1>;
}
```

</div>

That's all it takes! Now you can internationalize your apps on the server side.

If you've encountered an issue, you can [explore the code for a working example](https://github.com/amannn/next-intl-example-next-13) ([demo](https://next-intl-example-next-13.vercel.app)).

If you're in a transitioning phase, either from the `pages` directory to the `app` directory, or from Client Components to the Server Components beta, you can apply [`NextIntlClientProvider`](/docs/next-13/client-components) additionally.

## Routing

### `Link`

`next-intl` provides a drop-in replacement for `next/link` that will automatically prefix the `href` with the current locale as necessary. If the default locale is matched, the `href` remains unchanged and no prefix is added.

```tsx
import {Link} from 'next-intl';

// When the user is on `/en`, the link will point to `/en/about`
<Link href="/about">About</Link>

// You can override the `locale` to switch to another language
<Link href="/" locale="de">Switch to German</Link>
```

### `useRouter`

If you need to navigate programmatically (e.g. in response to a form submission), `next-intl` provides a convience API that wraps `useRouter` from Next.js and automatically applies the locale of the user.

```tsx
'use client';

import {useRouter} from 'next-intl/client';

const router = useRouter();

// When the user is on `/en`, the router will navigate to `/en/about`
router.push('/about');
```

### `usePathname`

To retrieve the pathname without a potential locale prefix, you can call `usePathname`.

```tsx
'use client';

import {usePathname} from 'next-intl/client';

// When the user is on `/en`, this will be `/`
const pathname = usePathname();
```

### `redirect`

If you want to interrupt the render of a Server Component and redirect to another page, you can invoke the `redirect` function from `next-intl`. This wraps [the `redirect` function from Next.js](https://beta.nextjs.org/docs/api-reference/redirect) and automatically applies the current locale.

```tsx
import {redirect} from 'next-intl/server';

export default async function Profile() {
  const user = await fetchUser();

  if (!user) {
    // When the user is on `/en/profile`, this will be `/en/login`
    redirect('/login');
  }

  // ...
}
```

## Using translations in Client Components

If you need to use translations or other functionality from `next-intl` in Client Components, the best approach is to pass the labels as props or `children` from a Server Component.

```tsx filename="[locale]/faq/page.tsx" {7-9}
import {useTranslations} from 'next-intl';
import Expandable from './Expandable';

export default function FAQEntry() {
  const t = useTranslations('FAQEntry');
  return (
    <Expandable title={t('title')}>
      <FAQContent content={t('description')} />
    </Expandable>
  );
}
```

```tsx filename="Expandable.tsx" {5,14-15}
'use client';

import {useState} from 'react';

function Expandable({title, children}) {
  const [expanded, setExpanded] = useState(false);

  function onToggle() {
    setExpanded(!expanded);
  }

  return (
    <div>
      <button onClick={onToggle}>{title}</button>
      {expanded && <div>{children}</div>}
    </div>
  );
}
```

This way your messages never leave the server and the client only needs to load the code that is necessary for initializing your interactive components.

If you need to integrate your translations with interactively-controlled state, you can still manage your translations on the server side by using one of the following techniques.

**Examples for state that can be read on the server side:**

- [Page- or search params](https://beta.nextjs.org/docs/api-reference/file-conventions/page)
- [Cookies](https://beta.nextjs.org/docs/api-reference/cookies)
- [Database state](https://beta.nextjs.org/docs/data-fetching/fundamentals)

There's [an article about using `next-intl` in Server Components](https://www.smashingmagazine.com/2023/03/internationalization-nextjs-13-react-server-components) which explores this topic in more detail, specifically [the section about adding interactivity](https://www.smashingmagazine.com/2023/03/internationalization-nextjs-13-react-server-components/#adding-interactivity-dynamic-ordering-of-photos).

If you absolutely need to use functionality from `next-intl` on the client side, you can wrap the respective components with `NextIntlClientProvider` ([example code](https://github.com/amannn/next-intl/blob/feat/next-13-rsc/packages/example-next-13-advanced/src/components/client/02-MessagesOnClientCounter/Counter.tsx)). Note however that this is a performance tradeoff since the relevant messages need to be serialized into the document and the used APIs from `next-intl` need to be included in the client-side bundle. Also note that `NextIntlClientProvider` doesn't automatically inherit configuration from `i18n.ts`, therefore make sure to provide all relevant props on the component.

## Global request configuration

`next-intl` supports the following [global configuration](/docs/usage/configuration):

- `formats`
- `defaultTranslationValues`
- `timeZone`
- `now`
- `onError`
- `getMessageFallback`

For the usage in Server Components, these can be configured in `i18n.ts`.

```tsx filename="i18n.ts"
import {headers} from 'next/headers';
import {getRequestConfig} from 'next-intl/server';

export default getRequestConfig(async ({locale}) => ({
  messages: (await import(`../messages/${locale}.json`)).default,

  // You can read from headers or cookies here
  timeZone: headers().get('x-time-zone') ?? 'Europe/Berlin'
}));
```

Note that the configuration object will be created once for each request and will then be made available to all Server Components in your app.

## Middleware configuration

The middleware handles redirects and rewrites based on the detected user locale.

There are two strategies for detecting the locale:

1.  [Prefix-based routing (default)](#prefix-based-routing-default)
2.  [Domain-based routing](#domain-based-routing)

Once a locale is detected, it will be saved in a cookie.

### Prefix-based routing (default)

Since your pages are nested within a `[locale]` folder, all routes are prefixed with one of your supported locales (e.g. `/de/about`). To keep the URL short, requests for the default locale are rewritten internally to work without a locale prefix.

**Request examples:**

- `/` ‚Üí `/en`
- `/about` ‚Üí `/en/about`
- `/de/about` ‚Üí `/de/about`

#### Locale detection

The locale is detected based on these priorities:

1. A locale prefix is present in the pathname (e.g. `/de/about`)
2. A cookie is present that contains a previously detected locale
3. The [`accept-language` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) is matched against the available `locales`
4. The `defaultLocale` is used

To change the locale, users can visit a prefixed route. This will take precedence over a previously matched locale that is saved in a cookie or the `accept-language` header.

**Example workflow:**

1. A user requests `/` and based on the `accept-language` header, the `de` locale is matched.
2. The `de` locale is saved in a cookie and the user is redirected to `/de`.
3. The app renders `<Link locale="en" href="/">Switch to English</Link>` to allow the user to change the locale to `en`.
4. When the user clicks on the link, a request to `/en` is initiated.
5. The middleware will update the cookie value to `en` and subsequently redirects the user to `/`.

### Domain-based routing

If you want to serve your localized content based on different domains, you can provide a list of mappings between domains and locales to the middleware.

**Example:**

- `us.example.com` (default: `en`)
- `ca.example.com` (default: `en`)
- `ca.example.com/fr` (`fr`)

```tsx filename="middleware.ts"
import createMiddleware from 'next-intl/middleware';

export default createMiddleware({
  // All locales across all domains
  locales: ['en', 'fr'],

  // Used when no domain matches (e.g. on localhost)
  defaultLocale: 'en',

  domains: [
    {
      domain: 'us.example.com',
      defaultLocale: 'en',
      // Optionally restrict the locales managed by this domain. If this
      // domain receives requests for another locale (e.g. us.example.com/fr),
      // then the middleware will redirect to a domain that supports it.
      locales: ['en']
    },
    {
      domain: 'ca.example.com',
      defaultLocale: 'en'
      // If there are no `locales` specified on a domain,
      // all global locales will be supported here.
    }
  ]
});
```

The middleware rewrites the requests internally, so that requests for the `defaultLocale` on a given domain work without a locale prefix (e.g. `us.example.com/about` ‚Üí `/en/about`). If you want to include a prefix for the default locale as well, you can add [`localePrefix: 'always'`](#always-use-a-locale-prefix).

#### Locale detection

To match the request against the available domains, the host is read from the `x-forwarded-host` header, with a fallback to `host`.

The locale is detected based on these priorities:

1. A locale prefix is present in the pathname and the domain supports it (e.g. `ca.example.com/fr`)
2. If the host of the request is configured in `domains`, the `defaultLocale` of the domain is used
3. As a fallback, the [locale detection of prefix-based routing](#locale-detection) applies

<Callout>

Since unknown domains will be handled with [prefix-based routing](#prefix-based-routing-default), this strategy can be used for local development where the host is `localhost`.

</Callout>

Since the middleware is aware of all your domains, the domain will automatically be switched when the user requests to change the locale.

**Example workflow:**

1. The user requests `us.example.com` and based on the `defaultLocale` of this domain, the `en` locale is matched.
2. The app renders `<Link locale="fr" href="/">Switch to French</Link>` to allow the user to change the locale to `fr`.
3. When the link is clicked, a request to `us.example.com/fr` is initiated.
4. The middleware recognizes that the user wants to switch to another domain and responds with a redirect to `ca.example.com/fr`.

### Further configuration

#### Always use a locale prefix

If you want to include a prefix for the default locale as well, you can configure the middleware accordingly.

```tsx filename="middleware.ts" {6}
import createMiddleware from 'next-intl/middleware';

export default createMiddleware({
  // ... other config

  localePrefix: 'always' // Defaults to 'as-needed'
});
```

In this case, requests without a prefix will be redirected accordingly (e.g. `/about` to `/en/about`).

Note that this will affect both prefix-based as well as domain-based routing.

#### Disable automatic locale detection

If you want to rely entirely on the URL to resolve the locale, you can disable locale detection based on the `accept-language` header and a potentially existing cookie value from a previous visit.

```tsx filename="middleware.ts" {6}
import createMiddleware from 'next-intl/middleware';

export default createMiddleware({
  // ... other config

  localeDetection: false // Defaults to `true`
});
```

Note that in this case other detection mechanisms will remain in place regardless (e.g. based on a locale prefix in the pathname or a matched domain).

#### Disable alternate links

The middleware automatically sets [the `link` header](https://developers.google.com/search/docs/specialty/international/localized-versions#http) to inform search engines that your content is available in different languages. Note that this automatically integrates with your routing strategy and will generate the correct links based on your configuration.

If you prefer to include these links yourself, you can opt-out of this behaviour.

```tsx filename="middleware.ts" {6}
import createMiddleware from 'next-intl/middleware';

export default createMiddleware({
  // ... other config

  alternateLinks: false // Defaults to `true`
});
```

## Localizing pathnames

If you want to localize the pathnames of your app, you can accomplish this by using appropriate [rewrites](https://nextjs.org/docs/api-reference/next.config.js/rewrites).

```js filename="next.config.js"
const withNextIntl = require('next-intl/plugin')();

module.exports = withNextIntl({
  experimental: {appDir: true},
  rewrites() {
    return [
      {
        source: '/de/√ºber',
        destination: '/de/about'
      }
    ];
  }
});
```

Since `next-intl` isn't aware of the rewrites you've configured, you likely want to make some adjustments:

1. Turn off [the `alternateLinks` option](#disable-alternate-links) in the middleware and provide [search engine hints about localized versions of your content](https://developers.google.com/search/docs/specialty/international/localized-versions) by yourself.
2. Translate the pathnames you're passing to the [routing APIs from `next-intl`](#routing) ([example](https://github.com/amannn/next-intl/blob/feat/next-13-rsc/packages/example-next-13-named-routes/)).

## Using internationalization outside of components

If you need to use translated messages in functions like `generateMetadata`, you can import awaitable versions of the functions that you usually call as hooks from `next-intl/server`.

```tsx filename="app/[locale]/layout.tsx"
import {getTranslations} from 'next-intl/server';

export async function generateMetadata() {
  const t = await getTranslations('Metadata');

  return {
    title: t('title'),
    description: t('description')
  };
}
```

These functions are available from `next-intl/server` for usage outside of components:

```tsx
import {
  getTranslations, // like `useTranslations`
  getFormatter, // like `useFormatter`
  getLocale, // like `useLocale`
  getNow, // like `useNow`
  getTimeZone // like `useTimeZone`
} from 'next-intl/server';
```

## CDN caching

Since `next-intl` is currently SSR-only, it's a good idea to use [CDN caching](https://vercel.com/docs/concepts/edge-network/caching#stale-while-revalidate) via [`headers`](https://nextjs.org/docs/api-reference/next.config.js/headers) in `next.config.js` to get the same level of performance from dynamic rendering as you'd get from static rendering ([learn more](https://youtu.be/bfLFHp7Sbkg?t=490)). Also note that [the Next.js Cache](https://nextjs.org/blog/next-13-2#nextjs-cache) improves the performance for dynamically rendered pages.

```js filename="next.config.js"
const ms = require('ms');
const withNextIntl = require('next-intl/plugin')();

module.exports = withNextIntl({
  // ... Other config

  headers() {
    return [
      {
        // Cache all content pages
        source: '/((?!_next|assets|favicon.ico).*)',
        headers: [
          {
            key: 'Cache-Control',
            value: [
              `s-maxage=` + ms('1d') / 1000,
              `stale-while-revalidate=` + ms('1y') / 1000
            ].join(', ')
          }
        ],

        // If you're deploying on a host that doesn't support the `vary` header (e.g. Vercel),
        // make sure to disable caching for prefetch requests for Server Components.
        missing: [
          {
            type: 'header',
            key: 'Next-Router-Prefetch'
          }
        ]
      }
    ];
  }
});
```

## Providing feedback

If you have feedback about using `next-intl` in the `app` directory, feel free to leave feedback in [the PR which implements the React Server Components support](https://github.com/amannn/next-intl/pull/149).
